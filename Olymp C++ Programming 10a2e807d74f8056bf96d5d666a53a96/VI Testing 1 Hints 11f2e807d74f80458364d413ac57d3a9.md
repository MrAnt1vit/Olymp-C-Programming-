# VI Testing 1. Hints

---

### A. Солдат и бананы

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image.png)

- Заметим, что стоимость $w$ **бананов:

$$
k+2k+...+wk=k(1+2+...+a)=k\frac{(w+1)w}{2}
$$

Поэтому вычислим суммарную стоимость $cost$ по этой формуле и проверим, хватает ли нам денег — если хватает, то выведем просто $0$, иначе — $cost-n$

```cpp
#include <iostream>

using namespace std;

void solve() {
    int k, n, w;
    cin >> k >> n >> w;

    int cost = k * (w + 1) * w / 2;

    if (cost <= n) {
        cout << 0;
        return;
    }
    cout << cost - n;
}

int main() {
    solve();

    return 0;
}
```

---

### B. Задача о делимости

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%201.png)

- В задаче нам требуется найти некоторый $x$, удовлетворяющий следующему условию:

$$
a+x\equiv0(mod\ b)\text{*}
$$

Или:

$$
a\equiv-x\equiv b-x(mod\ b)
$$

То есть остаток $a$ от деления на $b$ должен быть равен $b - x$. Из этого имеем, что

$$
x=b-a \text{\%} b
$$

При этом, отдельно нужно рассмотреть случай, когда $a$ кратно $b$, ведь в таком случае наша формула будет работать неправильно — мы получим, что $x$ равен $b$. Поэтому просто ещё раз посчитаем остаток по модулю $b$: 

$$
x=(b-a\text{\%}b)\text{\%}b
$$

```cpp
#include <iostream>

using namespace std;

void solve() {
    int a, b;
    cin >> a >> b;

    cout << (b - a % b) % b << '\n';
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

* Данное выражение читается как “$a+x$ сравнимо с $0$ по модулю $b$”. Это означает, что выражение в левой части даёт такой же остаток при делении на $b$, как и выражение в правой части. Говоря “языком программирования”, можно сказать, что 

$$
a\equiv b(mod\ x) \iff (a-b)\text{\%}x==0 \iff (a - b) \text{ делится на x}
$$

---

### C. Средство от бессонницы

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%202.png)

- Проходимся циклом $for$ по всем всем значениям с $1$ по $d$, проверяя при этом делимость на $k\text{,}\ l\text{,}\ m$ и $n$ (для этого как раз и нужна функция $check()$)

```cpp
#include <iostream>

using namespace std;

bool check(int num, int first, int second, int third, int fourth) {
    if (!(num % first)) { return true; }
    if (!(num % second)) { return true; }
    if (!(num % third)) { return true; }
    if (!(num % fourth)) { return true; }
    return false;
}

void solve() {
    int k, l, m, n, d;
    cin >> k >> l >> m >> n >> d;

    int cnt = 0;
    for (int i = 1; i <= d; ++i) {
        if (check(i, k, l, m, n)) {
            ++cnt;
        }
    }

    cout << cnt;
}

int main() {
    solve();

    return 0;
}
```

---

### D. Скобки

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%203.png)

- Задача называется “Проверка на ПСП*”. Заметим, что если после открывающей скобки через некоторое количество символов будет закрывающая скобка другого вида, причём закрывающей скобки того же типа среди символов не встретилось, то тогда это не ПСП. Поэтому воспользуемся стеком — будет добавлять скобки в стек: в случае, если скобка закрывающая, проверим, что предыдущая скобка того же типа — в таком случае удалим последнюю сохраненную скобку, иначе — добавим в стек текущую. Тогда в случае невозможности получения правильного выражения путём добавления цифр стек к концу работы алгоритма не будет пуст. Затем, просто проверив, остались ли в стеке скобки, мы легко можем ответить “Yes” или “No”.

```cpp
#include <iostream>
#include <stack>

using namespace std;

void solve() {
    int len;
    string str;
    cin >> len >> str;

    stack<char> st;
    for (auto chr : str) {
        if (st.empty()) { st.push(chr); }
        else if (chr == ')' && st.top() == '(') { st.pop(); }
        else if (chr == ']' && st.top() == '[') { st.pop(); }
        else if (chr == '}' && st.top() == '{') { st.pop(); }
        else { st.push(chr); }
    }

    if (st.empty()) {
        cout << "Yes";
        return;
    }
    cout << "No";
}

int main() {
    solve();

    return 0;
}
```

* Правильная скобочная последовательность

---

### E. Вася и шахматы

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%204.png)

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%205.png)

- Рассмотрим $2$ случая — когда $n$ чётно и наоборот:

$\ \ \ \circ \$ $n$ не кратно $2$:

В таком случае чёрный ферзь может просто совершать симметричные белому ферзю ходы. Когда белый ферзь съест какую-либо пешку на среднем столбце, чёрный ферзь сможет сходить симметрично — то есть сможет съесть белого ферзя и выиграть

$\ \ \ \circ \$ $n$ кратно $2$:

В этом случае белые могут свести ситуацию к уже разобранному случаю — просто сходить на поле $(1, 2)$. Тогда складывается абсолютно такая же ситуация, только на этот раз ход чёрных, при этом точно так же белые будут повторять каждый ход чёрных симметрично. Это гарантирует победу белых

```cpp
#include <iostream>

using namespace std;

void solve() {
    int n;
    cin >> n;

    if (n % 2) {
        cout << "black";
        return;
    }
    cout << "white\n1 2";
}

int main() {
    solve();

    return 0;
}
```

---

### F. Порядок чатов

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%206.png)

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%207.png)

- Будем рассматривать чаты в обратном порядке обращения к ним, так как выше находиться будет тот чат, в который мы заходили позже. При этом будем проверять, будет ли обращение к этому чату ещё раз (так как идём в обратном порядке, мы заранее можем определить, будем ли в будущем ещё раз обращаться к чату). Для этого воспользуемся структурой $set$, в которую будем добавлять уже рассмотренные чаты, чтобы не выводить их дважды и проверять, что они уже были выше.

```cpp
#include <iostream>
#include <set>
#include <vector>

using namespace std;

void solve() {
    int n;
    cin >> n;

    vector<string> vec(n);
    for (int i = 0; i < n; ++i) {
        cin >> vec[n - i - 1];
    }

    set<string> st;
    for (auto& str : vec) {
        if (!st.contains(str)) {
            st.insert(str);
            cout << str << '\n';
        }
    }
}

int main() {
    solve();

    return 0;
}
```

---

### G. Особая перестановка

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%208.png)

- Заметим, что нам подходит циклический сдвиг последовательности $1,2,...,n$ на $1$. Тогда на позиции $1$ будет стоять число $n$, а на позициях $i\neq1$ будет стоять число $i-1$

```cpp
#include <iostream>

using namespace std;

void solve() {
    int n;
    cin >> n;

    cout << n << ' ';
    for (int i = 1; i < n; ++i) {
        cout << i << ' ';
    }
    cout << '\n';
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

---

### H. Повторное шифрование

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%209.png)

- Заметим, что индексы, по которым нужно искать правильные буквы формируют сумму арифметической прогрессии (сначала под индексом $0$, затем под индексом $1$, $3$, $6$ и т.д., то есть сумма чисел от $0$ до $n$). С помощью цикла $for$ реализуем изменение текущего индекса сначала на $1$, затем на $2$, на $3$ и т.д., то есть по сути реализуем вычисление суммы арифметической прогрессии

```cpp
#include <iostream>

using namespace std;

void solve() {
    int n;
    string str;
    cin >> n >> str;
    
    for (int i = 0, range = 1; i < n; i += range, ++range) {
        cout << str[i];
    }
}

int main() {
    solve();

    return 0;
}
```

---

### I. Обратная польская запись

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%208.png)

- Буквально храним на стеке актуальные числа и выполняем операции при необходимости. По сути надо грамотно написать то, что требуется в задаче. При реализации подобного рекомендую визуально разделять на блоки так, чтобы самим было проще ориентироваться и искать баги при необходимости

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

void solve() {
    stack<int> st;
    string str;
    while (cin >> str) {
        if (str == "+") {
            int x = st.top(); st.pop();
            int y = st.top(); st.pop();
            st.push(x + y);
            continue;
        }
        if (str == "-") {
            int y = st.top(); st.pop();
            int x = st.top(); st.pop();
            st.push(x - y);
            continue;
        }
        if (str == "*") {
            int x = st.top(); st.pop();
            int y = st.top(); st.pop();
            st.push(x * y);
            continue;
        }
        st.push(stoi(str));
    }
    cout << st.top() << '\n';
}

int main() {
    solve()
    return 0;
}
```

---

### J. Любимая последовательность

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%2010.png)

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%2011.png)

- Задача на реализацию. Заведем два индекса $left$ и $right$, которые будут указывать на место, куда встанет следующий элемент с левой и правой стороны соответственно. Далее будем двигать соответствующий элемент в зависимости от чётности текущего индекса. В конце выведем полученный массив

```cpp
#include <iostream>
#include <vector>
using namespace std;

void solve() {
    // code can be much shorter, you can try to make it shorter =)
    int n;
    cin >> n;
    vector<int> a(n), res(n);
    int left = 0, right = n - 1;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {
            res[i] = a[left++];
        } else {
            res[i] = a[right--];
        }
    }
    for (auto i: res) {
        cout << i << ' ';
    }
    cout << '\n';
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    
    return 0;
}
```

- Можно выводить результат сразу и не создавать вектор $res$, здесь это сделано для пущей наглядности

---

### K. Предметный указатель

![image.png](VI%20Testing%201%20Hints%2011f2e807d74f80458364d413ac57d3a9/image%2012.png)

- Задача на реализацию и использование структуры $map$ (можно обойтись и без неё, и даже асимптотика получится лучше, но я приведу решение со словарем). Заведем $map$, где для каждого числа будем хранить список значений, которые ему соответствуют. Далее пройдем в конце по словарю и выведем получившиеся значения (хранить в $set$’е, чтобы не получать повторения, а также, чтобы выводить сразу в отсортированном порядке)

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <set>
using namespace std;

void solve() {
    map<int, set<string>> mp;
    int n, x;
    string str;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> str >> x;
        mp[x].insert(str);
    }

    for (auto& [ind, vec]: mp) {
        cout << ind << ' ';\
        for (auto& i: vec) {
            cout << i << ' ';
        }
        cout << '\n';
    }
}

int main() {
    solve();
    
    return 0;
}
```

---

### Ending

$© \text { Created by Anton Vitiuk \& Simon Khasanov 10.2024}$

Anton: [telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)

Simon: [telegram](https://t.me/the_semen1) [vk](https://vk.com/1thesemen)