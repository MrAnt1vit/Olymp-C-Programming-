# V Set. Map. And other.

---

# Set

### Идея + описание

- Сет это по сути множество (как в математике). Туда элементы можно добавлять и удалять. Подробнее дальше
- Смысл его в том, что это работает быстро (почти все операции за O(1) или за O(log n)).
- Для использования нужна библиотека <set>.

---

### Методы (Основные)

```cpp
#include <iostream>
#include <set>
using namespace std;

void solve() {
    set<int> s;
    set<string> sample = {"aa", "bb", "cc"};

    for (int i = 0; i < 10; i += 2)
        s.insert(i);
    // 0 2 4 6 8

    cout << s.size() << '\n';         // 5
    cout << s.empty() << '\n';        // false
    s.erase(4);
    s.erase(5);
    s.clear();
    cout << s.contains(6) << '\n'; // true
    cout << s.count(6) << '\n';    // 1
    // s.contains(x) <=> s.count(x) == 0
}

int main() {
    solve();
    return 0;
}
```

> set<int> s;
> 

Создание сета (аналогично вектору указываем тип элементов внутри).

> set<string> sample = {"aa", "bb", "cc"};
> 

Сет можно создать от любого типа, где их можно сравнивать.
Также можно сразу задать сет перечислением элементов.

> s.insert(i);
> 

Добавление элемента в сет. Работает за O(log n), где n - размер сета на момент добавления.

- Откуда берется log n?
Давайте представим сет как массив (в реальности это не совсем так), попробуем найти место, где будет лежать наш новый элемент. Для этого воспользуемся бинарным поиском.
- Если вы не знаете что это, то вот обьяснение на пальцах: смотрим на элемент в центре массива. Если он меньше добавляемого, то значит новое место лежит правее (аналогично, если наоборот). Так мы отсекли половину массива.Сделав тоже самое на оставшейся половине, останется четверть. Таким образом после каждой проверки мы уменьшаем число возможных позиций вдвое. А значит надо $\log_2 n$ операций.

> s.size();
> 

Узнаем размер сета. 
Асимптотика: O(1).

> s.empty();
> 

Проверяем, пустой ли сет. По сути тоже самое, что s.size() == 0.
Асимптотика: O(1).

> s.erase(4);
> 

Удаляем элемент по его значению.
Асимптотика O(log n). Аналогично .insert(x).

> s.erase(5);
> 

При попытке удаления элемента, которого нет в сете, ничего не произойдет (не будет RE).

> s.clear();
> 

Полностью очищаем сет.
Асимптотика O(n). Т.к. надо пройтись по всем элементам и удалить.

> s.contains(6);
> 

Проверка, что в сете лежит некоторый элемент. Возвращает true/false.
Асимптотика O(log n). Аналогично добавлению.

> s.count(6);
> 

Считаем кол-во элементов в сете. По сути всегда 0 или 1.

- Более полезная функция в multiset’е.

---

### Методы (с указателями)

```cpp
#include <iostream>
#include <set>
using namespace std;

void solve() {
    set<int> s;
    for (int i = 0; i < 10; i += 2)
        s.insert(i);
    // 0 2 4 6 8
    
    s.begin(); s.end();
    cout << *s.find(4) << '\n';
    cout << *s.lower_bound(4) << '\n'; // 4
    cout << *s.upper_bound(4) << '\n'; // 6
    
    s.erase(s.begin());
    s.erase(s.find(4));
    s.erase(s.upper_bound(6));
}

int main() {
    solve();
    return 0;
}
```

> s.begin();
s.end();
> 

Получаем итераторы (указатели) как и в остальных контейнерах.

- Напоминание. begin() указывает на первый элемент, а end() **за** последний.

Асимптотика: O(1).

> s.find(4);
> 

Получаем указатель на элемент сета. Если такого элемента нет, то получаем .end().
Асимптотика: O(log n).

- Напоминание: итератор можно разыменовать с помощью *.

> s.lower_bound(4);
> 

Получаем указатель на первый элемент сета, который **больше или равен** искомого.
Асимптотика: O(log n). 

> s.upper_bound(4);
> 

Получаем указатель на первый элемент сета, который **строго больше** искомого.
Асимптотика: O(log n).

> s.erase(s.begin());
> 

Удаление по указателю. Здесь удаление минимального элемента.
Асимпотика: O(log n).

> s.erase(s.find(4));
> 

Удаление по указателю. Здесь удаление элемента по занчению (больше нужно в multiset’e).
Асимпотика: O(log n).

> s.erase(s.upper_bound(6));
> 

Удаление по указателю. Здесь удаление первого элемента больше заданого.
Асимпотика: O(log n).

---

### Пример задачи (задача A)

![image.png](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556/image.png)

```cpp
#include <iostream>
#include <set>

using namespace std;

void solve() {
    set<int> s;
    int n;
    while (cin >> n) {
        s.insert(n);
    }
    cout << s.size() << '\n';
}

int main() {
    solve();
    return 0;
}
```

- Если мы добавим все элементы в сет, то повторные просто не добавятся, а значит его размер будет в точности равен числу уникальных элементов.

---

# Map

### Идея + описание

- В какой-то степени map это сет пар. Но в этих парах первый элемент это “ключ”, а второй “значение”. То есть можно обращаться как по индексу в векторе, но это не в чистом виде индекс. По нему можно получить значение той пары, в которой первый элемент есть искомый ключ.
- Смысл его в том, что это работает быстро (почти все операции за O(1) или за O(log n)).
- Для использования нужна библиотека <map>.

---

### Методы (Основные)

```cpp
#include <iostream>
#include <map>
using namespace std;

void solve() {
    map<string, int> mp;

    mp["abc"] = 1;
    cout << mp["aaa"] << '\n';
    cout << mp.count("abc") << '\n';
    cout << mp.contains("abc") << '\n';
    mp.clear();
    cout << mp.empty() << '\n';
    cout << mp.size() << '\n';
    cout << mp.at("abc") << '\n';
    mp.erase("aaa");
    mp.insert({"bbb", 1});
}

int main() {
    solve();
    return 0;
}
```

> map<string, int> mp;
> 

Указываем тип ключа и тип значений map’а. 

> mp[”abc”] = 1;
> 

Задаем значение элемента по ключу.
Асимтпотика: O(log n).

> mp[”aaa”];
> 

Если элемента не было, то он будет создан и заполнен значением по умолчанию.

> mp.count(”abc”);
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) узнаем кол-во элементов с искомым ключом (тоже 0 или 1 и более применимо в multimap’e).
Асимптотика: O(log n).

> mp.contains(”abc”);
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) проверка на то, что по такому ключу существует элемент.
Асимптотика: O(log n).

> mp.clear();
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) полностью очищаем контейнер.
Асимптотика: O(n). 

> mp.empty();
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) проверяем словарь на пустоту.
Асимптотика: O(1).

> mp.size();
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) получаем размер контейнера.
Асимптотика: O(1).

> mp.at(”abc”);
> 

Если элемент по этому ключу есть, то работает также как mp[”abc”], а если нет, то получаем RE.
Асимптотика: O(log n). 

> mp.insert({"bbb", 1});
> 

Добавляем пару “ключ-значение” в словарь. По сути тоже самое, что mp[”bbb”]=1; Более актуально для multimap’а.

> mp.erase("aaa");
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) удаляем пару по ключу (т.е. по первому элементу пары).
Асимптотика: O(log n).

---

### Методы (с указателями)

```cpp
#include <iostream>
#include <map>
using namespace std;

void solve() {
    map<int, int> mp;

    for (int i = 0; i <= 10; i += 2) {
        mp[i] = i / 2;
    }
    // 0 - 0
    // 2 - 1
    // 4 - 2
    // 6 - 3
    // 8 - 4
    // 10 - 5

    mp.begin(); mp.end();
    cout << mp.lower_bound(4)->second;
    cout << mp.upper_bound(4)->second;
    mp.erase(mp.begin());
    cout << mp.find(2)->second;
}

int main() {
    solve();
    return 0;
}
```

> mp.begin();
mp.end();
> 

[Аналогично сету.](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) Но помним, что получаем указатель на пару, а не на значение.
Асимптотика: O(1).

- Так как указатель на пару, то по нему можно получить конкретное поле через ->.

> mp.lower_bound(4);
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) получаем указатель на первую пару, в которой ключ не меньше искомого.
Асимптотика: O(log n).

> mp.upper_bound(4);
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) получаем указатель не первую пару, где ключ сторго больше искомого.
Асимптотика: O(log n);

> mp.erase(mp.begin());
> 

[Аналогично сету,](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556.md) можно удалять по указателю на пару.
Асимптотика O(log n);

---

### Пример задачи (задача C)

![image.png](V%20Set%20Map%20And%20other%201182e807d74f806fbc37d1b0e093e556/image%201.png)

```cpp
#include <iostream>
#include <set>
#include <vector>
#include <map>

using namespace std;

void solve() {
    map<string, int> cnt;

    string str;
    while (cin >> str) {
        cnt[str]++;
    }

    string res=cnt.begin()->first;
//    string res="";
    for (auto it: cnt) {
        if (it.second > cnt[res]) res=it.first;
    }
    cout << res;
}

int main() {
    solve();
    return 0;
}
```

- Учтем, что перебирая ключи в парах (или сами пары), то они будут идти в порядке возрастания.
- Также рекомендую вспомнить что такое for(auto … : …) {}

---

# unordered_set, unordered_map

### Идея + описание

- По сути это те же set и map, но элементы в них хранятся не по возрастанию. Благодаря этому многие операции работают за O(1), но с большой контсантой.
- При этом многие методы, основнные на отсортированности, не доступны для них.
- Нужны библиотеки <unordered_map> и <unordered_set>

---

### unordered_set

- Почти все методы работают аналогично сету, если не указано обратного.

> unordered_set<int> s;
> 

> set<int> sample = {1, 2, 3};
> 

> s.insert(i); → O(1)
> 

Добавление элемента в сет. Работает за O(1), но у контсанта этого метода настолько велика, что в целом сопоставима с O(log n) в задачах. Так что в зависимости от ситуацаций можно попробовать заменить set на unordered_set и, возмонжо, будет работать быстрее.

> s.size();
> 

> s.empty();
> 

> s.erase(4);  → O(1)
> 

> s.clear();
> 

> s.contains(6); → O(1)
> 

> s.count(6); → O(1)
> 

> s.begin();
s.end();
> 

> s.find(4); → O(1)
> 

> !!! s.lower_bound(4); - **Такого нет**
> 

> !!! s.upper_bound(4); - **Такого нет**
> 

> s.erase(s.begin()); → O(1)
> 

---

### unordered_map

- Почти все методы работают аналогично сету, если не указано обратного.

> map<string, int> mp;
> 

> mp[”abc”] = 1; → O(1)
> 

> mp.count(”abc”); → O(1)
> 

> mp.contains(”abc”); → O(1)
> 

> mp.clear();
> 

> mp.empty();
> 

> mp.size();
> 

> mp.at(”abc”);
> 

> mp.insert({"bbb", 1});
> 

> mp.erase("aaa"); → O(1)
> 

> mp.begin();
mp.end();
> 

> !!! mp.lower_bound(4); - **Такого нет**
> 

> !!! mp.upper_bound(4); - **Такого нет**
> 

> mp.erase(mp.begin());
> 

---

# multiset, multimap

### Идея + описание

- Отличие от сета и мэпа в том, что можно хранить по несколько элементов / пар элементов.
- При этом многие методы, основнные на отсортированности, не доступны для них.
- Нужны библиотеки <set> и <map>

---

### multiset

- Почти все методы работают аналогично сету, если не указано обратного.

> multiset<int> s;
> 

> set<int> sample = {1, 1, 1}; - Элементы могут повторяться
> 

> s.insert(i); - Элементы могут повторяться.
> 

> s.size();
> 

> s.empty();
> 

> s.erase(4);  - Удаляет все элементы с этим хначением, а не только одно.
> 

> s.clear();
> 

> s.contains(6);
> 

> s.count(6); - Здесь число элементов может быть больше 1.
> 

> s.begin();
s.end();
> 

> s.find(4); - Получаем указатель на один из элементов с таким значением.
> 

> s.lower_bound(4);
> 

> s.upper_bound(4);
> 

> s.erase(s.begin()); - Как раз чтобы удалить только 1 элемент из мультисета необходимо использовать удаление по указателю.
> 

---

### multimap

- Почти все методы работают аналогично сету, если не указано обратного.

> multimap<string, int> mp;
> 

> !!! mp[”abc”] = 1; - **Такого нет**
> 

> mp.count(”abc”); - Число пар может быть больше 1.
> 

> mp.contains(”abc”);
> 

> mp.clear();
> 

> mp.empty();
> 

> mp.size();
> 

> !!! mp.at(”abc”); - **Такого нет**
> 

> mp.insert({"bbb", 1}); - Т.к. нельзя обращаться по [], то добавлять можно только так.
> 

> mp.erase("aaa"); - Удаление всех элементов с таким ключом.
> 

> mp.begin();
mp.end();
> 

> mp.lower_bound(4);
> 

> mp.upper_bound(4);
> 

> mp.erase(mp.begin()); - Удаление по указателю позволяет удалить один элемент (а ведь значения в парах могут быть разные).
> 

---

# Ending

- Еще есть unordered_multiset и unordered_multimap. По сути это обьединение соответствующих типов. При желании можете ознакомиться в интернете.

$© \text { Created by Anton Vitiuk 10.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)