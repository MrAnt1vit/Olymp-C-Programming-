# VI Testing 1. Key Tasks

> На занятии был контроль по блоку, так что здесь будут некоторые задачи со всех тем, которые я считаю важными и умение решать их может помочь в будущем. (Например, некоторые из них встречаются достаточно часто в качестве подзадачи. Иногда, буквально в таком же виде.)
> 

---

### II.H Котлеты

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image.png)

- Для начала надо понять, почему в последнем примере ответ 21, а не 24. Казалось бы, мы кладем 2 котлеты, жарим их с двух сторон (это 6 минут), делаем так 3 раза, получаем, что у нас 6 котлет пожарено за 18 минут. Тогда пожарив последнюю, получится 24.
- Но мы можем сделать по другому. Пожарим по 3 минуты 1ую и 2ую котлеты. Дальше оставим 2ую и 3ью, а затем 1ую и 2ую. Получаем, что за 9 минут мы пожарили 3 котлеты. А для оставшихся 4х мы можем делать то же, что и раньше. Тогда как раз получится 9 + 4 * 3 = 21 минута.
- Теперь заметим, что если у нас достаточно много котлет, то мы можем считать просто их стороны и выяснять, сколько времени нам понадобится, чтобы просто пожарить 2m сторон. В действительности если котлет хотя бы столько же, сколько мест на сковороде, то такая логика применима.
- Но если котлет меньше, чем мест, то, очевидно нам понадобится просто 2k минут.

```cpp
#include <iostream>
using namespace std;

void solve() {
    int n, m, k;
    cin >> n >> k >> m;
    if (m >= n)
        cout << (2 * m + n - 1) / n * k;
    else
        cout << 2 * k;
}

int main() {
    solve();
    return 0;
}
```

---

### II.K Краски

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%201.png)

- В этой задаче надо осознать, что она выглядит сложно, но в действительности имеет очень простое решение.
- Представим, что мы зафиксировали какой-то отрезок и у него есть какая то величина (r - l - c(l, r)). Тогда, если мы попробуем его увеличить (на 1 элемент влево или вправо), то эта величина либо не изменится, либо станет только больше.
- Значит, что пока мы увеличиваем отрезок наш ответ точно не становится хуже. Ну а это уже означает, что взяв весь массив как отрезок, мы получим максимальный результат (да, возможно можно взять и отрезок поменьше, но нас никто об этом не просит)

```cpp
#include <iostream>
using namespace std;

void solve() {
    int n;
    cin >> n;
    int x;
    for (int i = 0; i < n; i++) cin >> x;
    cout << 1 << ' ' << n << '\n';
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

### III.H I Wanna Be the Guy

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%202.png)

- Можно просто с помощью сета закинуть туда все элементы и проверить, что его размер равен n.
- Но тогда и асимптотика будет O(n log n), что не критично, но можно лучше. Для этого заметим, что все элементы от 1 до n.
- Тогда создадим вектор на n элементов и отметим там все, что встречаются у нас. А потом проверим, что все элементы были отмечены.

---

### III.I Киану Ривз

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%203.png)

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%204.png)

- Аналогично, сама задача выглядит куда сложнее чем есть на самом деле.
- Если нулей и единиц разное число, то одна часть подходит, а если равное, то можно просто откусить у строки один символ и таким образом получить две строки.

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

void solve() {
    int n;
    cin >> n;
    string str;
    cin >> str;
    if (count(str.begin(), str.end(), '1') == n / 2 && n % 2 == 0) {
        cout << 2 << '\n' << str[0] << ' ';
        for (int i = 1; i < n; i++) cout << str[i];
    } else {
        cout << 1 << '\n' << str << '\n';
    }
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

### III.K Побег

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%205.png)

- Разобьем решение на две части.
- Сначала заметим, что если у каждой клетке удалить правую сторону, то такая расстановка позволит выполнить условие. Получаем ответ ab.
- Тепреь покажем, что меньше не получится. Для этого поймем, что если убрано меньше, чем ab стен, то обьединить мы сможем не больше чем ab областей (а их по сути ab + 1, включая внешнюю). А значит будут две области, которые не соеденены.
- Получаем, что ответ всегда ab.

---

### IV.E Минимум в окне

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%206.png)

- Относительно сложная для понимания, но полезная на практике задача.
- Рекомендую просмотреть построчно, что происходит тут и, по возможности, разобрать.
- Возьмем дек, в нем будем хранить индексы элементы начального массива. Далее рассмотрим первые k элементов. Рассматривая очередной элемент добавим его в конец, но при этом удалим те из добаленных, которые уже точно не станут ответом для будущих отрезков (то есть те элементы с конца, которые больше ≥ текущего).
- Получим, что в первом элементе дека как раз будет лежать минмиум на первом отрезке.
- Двигаясь по остальным элементам будем удалять из начала тот, что уже вышел за границу и добавлять очередной в конец, опять же, удаляя те, которые больше не пригодятся.
- *Для простоты написания кода я в начале добавлю k - 1 элемент, а дальше в цикле рассмотрю все окна.
- *Храним мы не элементы, а индексы, чтобы можно было понять, вышел элемент за границу отрезка текущего или еще нет.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <deque>
using namespace std;

void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    deque<int> deq;
    for (int i = 0; i < k - 1; i++) {
        while (!deq.empty() && a[deq.back()] >= a[i]) deq.pop_back();
        deq.push_back(i);
    }
    for (int i = k - 1; i < n; i++) {
        while (!deq.empty() && a[deq.back()] >= a[i]) deq.pop_back();
        deq.push_back(i);
        if (deq.front() <= i - k) deq.pop_front();
        cout << a[deq.front()] << endl;
    }
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

### IV.G Гистограмма

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%207.png)

- Также трудная для понимания задача, но иногда применимая на олимпиадах.
- Разобьем задачу не несколько подзадач. Максимальная высоты прямоугольника это одна из высот столбиков (если мы нашли некоторый прямоугольник с другой высотой, значит можно увеличить его высоту до высоты какого-либо столбика.
- Идейно будем решать задачу так: пройдем по столбцам и будем рассматривать их как тот, который является высотой прямоугольника. Тогда для него надо понять, как далеко мы можем отодвинуться “налево”, и, соответственно, “направо”.
- Но если делать это буквально как написано, то получится решение за O(n^2). Поэтому сначала надо для каждого столбца узнать, как далеко мы можем пройти “налево”. Получили подзадачу в виде: для каждого элемента найти первый слева такой, что он меньше текущего.
    - Для этого заведем стек, будем проводить некую аналогию с прошлой задачей.
    - Добавляем новый элемент туда. Но перед этим удаляем все те, которые уже не станут овтетом для будущих элементов (т.е. все те, которые больше текущего).
    - Перед добавлением текущего элемента, но после удаления лишних наверху стека как раз останется индекс первого слева элемента (искомого).
- Проделаем аналогичную логику для элементов с правой стороны.
- Теперь мы уже можем просто перебрать столбики, рассматривая очередной в качестве верхней границы прямоугольника.
- *Важное замечение, что ответ может не помесится в int.

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n), left(n), right(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    stack<int> st;
    for (int i = 0; i < n; i++) {
        while (!st.empty() && a[st.top()] >= a[i]) st.pop();
        if (st.empty()) left[i] = -1;
        else left[i] = st.top();
        st.push(i);
    }
    while (!st.empty()) st.pop();
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && a[st.top()] >= a[i]) st.pop();
        if (st.empty()) right[i] = n;
        else right[i] = st.top();
        st.push(i);
    }

    long long ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, (long long)(right[i] - left[i] - 1) * a[i]);
    }
    cout << ans;
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

### IV.H Обратная польская запись

![image.png](VI%20Testing%201%20Key%20Tasks%2011b2e807d74f80df8868d9948b0304b5/image%208.png)

- Буквально храним на стеке актуальные числа и выполняем операции при необходимости.

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

void solve() {
    stack<int> st;
    string str;
    while (cin >> str) {
        if (str == "+") {
            int x = st.top(); st.pop();
            int y = st.top(); st.pop();
            st.push(x + y);
            continue;
        }
        if (str == "-") {
            int y = st.top(); st.pop();
            int x = st.top(); st.pop();
            st.push(x - y);
            continue;
        }
        if (str == "*") {
            int x = st.top(); st.pop();
            int y = st.top(); st.pop();
            st.push(x * y);
            continue;
        }
        st.push(stoi(str));
    }
    cout << st.top() << '\n';
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

### Ending

$© \text { Created by Anton Vitiuk 10.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)