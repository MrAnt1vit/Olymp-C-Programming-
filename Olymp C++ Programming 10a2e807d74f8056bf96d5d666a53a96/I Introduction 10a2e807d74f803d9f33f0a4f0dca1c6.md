# I Introduction

---

# Первая программа

- Так выглядит “базовая” программа на C++, разберем что здесь происходит:

```cpp
#include <iostream>

using namespace std;

int main() {
		/* code */
		return 0;
}
```

> #include <iostream>
> 

Через #include подключаются различные библиотеки, в частности здесь библиотека iostream. 
Пока что можно воспринимать ее как подключение основных функций, которые мы будем использовать.

> using namespace std;
> 

Эту строчку можно пока понимать как “то, что просто должно быть”. Можете подробнее прочитать про это в интернете (я скажу пару слов на следующих занятиях). На самом деле достаточно много олимпиадников-школьников, которые не знают “полностью” что эта строка делает)

> int main() {}
> 

Основная функция, которая вызывается, когда мы запускаем код. Подробнее про функции поговорим дальше. Так что просто знайте, что здесь мы пишем код и вызываем другие функции.

> return 0;
> 

Любая функция что-либо возвращает (*если она не void). В частности main() должна вернуть 0, если выполнилась корректно.

> //
/* … */
> 

Комментарии. // используется для комментирования одной строки, а /* … */ используется для блока кода, который необходимо закомментировать. 

---

# Основные типы данных

- Рассмотрим основные типы данных, которые используются в C++.

```cpp
#include <iostream>

using namespace std;

int main() {
		int a;
		long long b;
		unsigned int c;
		unsigned long long d;
		
		bool e;
		
		float f;
		double g;
		
		char h;
		string i;
		
		1;
		1u;
		1ll;
		1ull;
		1.0;
		'';
		"";
				
		return 0;		
}
```

> int a;
> 

Стандартный целочисленный тип, занимает 32 бита (4 байта), а значит хранит числа в диапазоне примерно $-2^{31}...\ 2^{31}$

> long long b;
> 

Также целочисленный тип, но занимающий больше места (64 бита = 8 байт), а значит и хранить может большие числа. Диапазон примерно $-2^{63}...\ 2^{63}$

> unsigned int;
unsigned long long;
> 

Те же самые типы, что и int/long long, но не хранящие “знак” числа. То есть хранят числа $0...\ 2^{32} - 1$ и $0...\ 2^{64} - 1$ соответственно. 

> bool e;
> 

Булевский тип, хранит true/false (0 или 1 в памяти). Занимает в памяти 1 бит.

> float f;
double g;
> 

Типы данных с плавающей точкой. Эти типы позволяют хранить в памяти дробные числа. Аналогично long long - double занимает больше места чем float и умеет хранить числа побольше или с большей точностью.

> char h;
string i;
> 

char - символ. Буквально хранит в себе один символ) string - строка, состоит из символов.

- Литеральный суффиксы

Написав просто число, оно будет восприниматься как int. Если же мы хотим задать число (без переменной) типа unsigned int, например, то можно использовать литеральные суффиксы (то есть написать u в конце). Аналогично ll → long long; ull → unsigned long long;

Если писать вместо числа .0 на конце, то число будет восприниматься как тип float.

В одинарных кавычках прописываются символы, например ‘c’.

В двойных кавычках прописываются строки, например “aboba”.

---

# Стандартные операции над типами

```cpp
#include <iostream>

using namespace std;

int main() {
		int a, b;
		cin >> a >> b;
		cout << a - 1 << ' ' << b * 2 << '\n';
		
		// operations + - * / %
		// a++ ++a b++ ++b
		
		// conditions == < > <= >= !=
		
		// -= += *= /= %=
		
		return 0;
}
```

> cin >> a >> b;
cout << a - 1 << ' ' << b * 2 << '\n';
> 

Команды, используемые для ввода/вывода чего либо через консоль.
В частности \n - символ переноса строки.

> + - * / %
> 

Операции с числами. Про / можно сказать, что целочисленные типы дают целочисленный результат, а дробные - дробный. % на целочисленных типах используется для получения остатка от деления одного числа на другое (5 % 2 == 1)

> ++ --
> 

Операторы, увеличивающие/уменьшающие число на единицу. Чем отличается a++ и ++a рассказывалось на занятии. Так как разница не критична, можете при необходимости почитать самостоятельно.

> == < > <= >= !=
> 

Операторы сравнения. Дают нам bool, если условие верное.
a == b проверка на равенство (a == b ↔ a и b равны)
a != b - true, если числа не равны.

> += -= /= *= %=
> 

a += 10 тоже самое a = a + 10 (аналогично с остальными операциями)

---

# Условия, ветвления, циклы.

```cpp
#include <iostream>

using namespace std;

int main() {
		int a, b;
		cin >> a >> b;
		if (a == 1 || a == 0 || a == -1) {
				// some code
		} else if (a == 10 && b == 0) {
				// some code
		} else if ((a > 10 && b > 10) || (a < 10 && b < 10)) {
				// some code
		} else {
				// some code
		}

		return 0;
}
```

> || &&
> 

В условиях помимо < ==  и т.д. можно использовать различные функции (например, string,empty()), а также || и && для того, чтобы объединять разные условия. 

Через || (или) перечисляются условия, когда необходимо лишь одно из условий.
Через && (и) перечисляются условия, когда необходимы все условия сразу. 

> if (condition) {}
> 

Выполняется, если условие внутри равно true.

> else if (cond) {}
> 

Аналогично, выполняется, если условие верно, но при условии что все if’ы до этого не выполнились.

> else {}
> 

Выполняется, если все if’ы не выполнились (все условия равны false).

```cpp
#include <iostream>

using namespace std;

int main() {
		int n;
		cin >> n;
		while (n > 0) {
				if (n > 100) {
					n -= 50;
					continue;
				}
				n--;
				if (n % 15 == 3) {
						break;
				}
		}
		std::cout << "OK\n";
		return 0;
}
```

> while (condition) {}
> 

Если условие верное (равно true), запускает тело цикла. После каждого прохода снова проверяет условие, и до тех пор пока оно верно продолжает запускать тело цикла.

> continue
> 

Ключевое слово continue используется, когда нужно прервать текущую итерацию цикла и начать следующую (если условие все еще выполняется)

> break
> 

Это ключевое слово нужно, когда неободимо прервать цикл совсем (без захода на следующую итерацию)

```cpp
#include <iostream>

using namespace std;

int main() {
		int n;
		cin >> n;
		for (int i = 0; i < n; i++) {
				if (i % 3 == 0) {
						continue;
				}
				if (i == 1000) {
						break;
				}
				int x;
				cin >> x;
		}
		cout << "OK\n";
		return 0;
}
```

> for (start; condition; end) {}
> 

Перед входом в цикл выполняется start.
Дальше пока condition верно, выполняется тело цикла (аналогично while).
После каждой итерации выполняется end

> break & continue
> 

break работает аналогично while, а continue с небольшим исключением, что end все равно выполняется (пропуская все что между continue и концом тела цикла).

---

# String… Char…

- Операции над string. Что с ним можно делать?)

```cpp
#include <iostream>

using namespace std;

int main() {
    string a; // a == ""
    string b = "aboba"; // b == "aboba"
    string c("str3"); // c == "str3"
    string d{'s', 't', 'r', '4'}; // d == "str4"
    
    string str;
    cin >> str;
    
    swap(a, str);
    swap(a, str);
    
    cout << str.size() << '\n';
    cout << str.length() << '\n';
    
    str.push_back('a');
    str += 'a';
    str += "aaa";
    str.pop_back();
    
    cout << str.front() << '\n';
    cout << str.back() << '\n';
    cout << str.find("a") << '\n';
    cout << str.empty() << '\n';
    
    str.clear();
    
    cout << str[0] << ' ' << str[1] << '\n';
    cout << str[str.size() - 1] - '0' << '\n';
    return 0;
}
```

> string a; // a == ""
string b = "aboba"; // b == "aboba"
string c("str3"); // c == "str3"
string d{'s', 't', 'r', '4'}; // d == "str4"
> 

Разные способы создания строки. По умолчанию она равна пустой строке.

> cin >> str;
> 

Ввод строки (считывает ее до первого разделяющего символа).

> swap(a, str);
> 

Меняет две строки местами (теперь в a лежит str и наоборот). Работает не только со строками, но и другими типами.

> str.size()
str.length()
> 

Функция возвращает размер строки. =)
”aboba”.size() == “aboba”.length() == 5 (в коде несколько условий через == писать нельзя!)

> str.push_back(’a’);
str += ‘a’;
> 

Добавляет символ в конце строки.

> str += “abc”;
> 

Можно складывать строки. Работает как обычная конкатенация.

> str.pop_back();
> 

Удаляет последний символ со строки.

> str.front();
str.back();
> 

Позволяют узнать первый/последний символ в строке.

> str.find(”abc”);
> 

Возвращает индекс первого вхождения “abc”. (если ее там нет, возвращает .size())

> str.empty() → bool
> 

true, если строка пустая, false иначе

> str.clear();
> 

Очищает строку от символов.

> str[0]; str[i];
> 

У строки можно получить конкретный символ по номеру (индексу). Нумерация от 0 до .size() - 1. 

> str[i] - ‘0’
> 

Если мы знаем, что символ - число, то вычев из нее код нуля можно получить целочисленное значение вместо символа (’9’ - ‘0’ == 9)

---

# Ending

$© \text { Created by Anton Vitiuk 09.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)