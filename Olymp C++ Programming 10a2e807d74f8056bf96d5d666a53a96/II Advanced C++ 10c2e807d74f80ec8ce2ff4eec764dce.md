# II Advanced C++

---

# Напоминания =)

```cpp
int main() {
    string str, str2, str3;

    cin >> str >> str2 >> str3;

    cout << str << '\n';
    cout << str2 << '\n';
    cout << str3 << '\n';

    return 0;
}
```

> Считывание строк работает не как в питоне!!
Строка считывается посимвольно до первого разделительного символа (пробел, перенос строки, таб)
> 

```cpp
#include <iostream>

using namespace std;

int main() {
    char c;
    cin >> c;
    cout << c - '0'; // '9' -> 9
    cout << c - 'a'; // 'b' -> 1; 'z' -> 25
}
```

> Символы это числа в памяти и цифры как символы имеют порядковые номера. Это позволяет при помощи вычитания символов получать численное значение, например, цифры.
> 

---

# Функции

### Глобально о функциях

```cpp
#include <iostream>

using namespace std;

int f() {
    cout << "f!!" << '\n';
    return 1;
}

void g(int a, int b) {
    cout << "void function" << '\n';
}

int main() {
    f();
    g(1, 2);
    return 0;
}
```

> int f() { … }
> 

Функция - нечто, что мы вызываем в других функциях (main - тоже функция)

Чтобы обьявить функцию, надо прописать возвращаемый тип (что функция вернет), имя функции, аргументы (в круглых скобках) и непосредственно тело функции

> return 1;
> 

Т.к. функция возвращает целочисленный тип, то в некоторой строке нам надо выйти из функции и “отдать” какое-то число. Как раз это делает return.

> void g(int a, int b) { … }
> 

Функция может не возвращать ничего, для этого вместо типа пишется void.

Чтобы передать некоторые аргументы в функцию, надо прописать собственно типы и переменные, которые туда передаются.

---

### Перегрузка функций

```cpp
void f(int x) {
    cout << x << ' ';
}

int f(int x, int y) {
    return x + y;
}
```

> Функции с одинаковыми именами можно создавать, это называется перегрузкой
> 

Как мы видим, у функций с одним именем может быть разный возвращаемый тип, это ни на что не влияет (нет правила, что они должны быть одинаковыми)

Здесь идет перегрузка по кол-ву аргументов

> f(1.0);
> 

Мы не обязаны вызывать функцию в точности от тех типов, которые прописаны. Например, в данном вызове произойдет конверсия float → int

```cpp
int add(int x, int y) {
    cout << "int\n";
    return x + y;
}

long long add(long long x, long long y) {
    cout << "long long\n";
    return x + y;
}

int main() {
    int a, b;  // int, but if long long -> long long version
    cin >> a >> b;
    cout << add(a, b);
    return 0;
}
```

> Перегрузка по типу аргументов
> 

Компилятор выбирает функцию, которая больше подходит (мы передаем два инта, видим, что есть подходящая функция и вызываем ее)

> Если бы у нас было две функции add(int x, long long y) и add(long long x, int y)
> 

В таком случае была бы ошибка компиляции (CE) т.к. просто нельзя выбрать, какая из них предпочтительнее

> Если удалить функцию от int
> 

Очевидно, все будет работать, просто неявно будет вызвано преобразование int → long long.

```cpp
#include <iostream>

using namespace std;

void f(double a) {
    cout << "double";
}

void f(int a) {
    cout << "int";
}

int main() {
    int i = 1;
    f(i); // ??

    float fl = 2;
    f(fl); // ??

    double d = 3;
    f(d); // ??

    long long ll = 4;
    f(ll); // ??
}
```

> int
> 

Тут есть полное соввпадение по int’y, поэтому все корректно

> double
> 

Тут есть полное соввпадение по double’y, поэтому все корректно

> float
> 

Нет точного совпадения, но при этом логично, что “расширить” float → double лучше, чем “обрезать” float → int. А значит выберется версия double

> long long
> 

Будет CE, т.к. “обрезать” long long → int и long long → double одинаково плохо с точки зрения компилятора. Поэтому он не может выбрать какую-то конкретную версию сам.
*Спойлер: конкретную версию можно вызвать от long long, но это далеко в будущем.

---

### Пример применения (из олимпиадного опыта =)

```cpp
#include <iostream>

using namespace std;

void solve() {
    // code
}

int main() {
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

> Что тут происходит?
> 

Часто в задачах есть мультитесты, когда вам вводят число тестов и они рассматриваются независимо бывает удобно вынести обработку каждого случая в отдельную функцию.

> int t = 1;
cin >> t;
> 

Считаем кол-во тестов. Если в задаче нет мультитестов, то строчку с cin можно просто закомментировать и тест будет 1.

> while (t--) { solve(); }
> 

Можно понять, что данный while выполнится как раз t раз.

---

### Передача по ссылке

```cpp
#include <iostream>

using namespace std;

void f(int& a) {
    a += 1;
}

int main() {
    int a = 1;
    f(a);
    cout << a << ' ';
    return 0;
}
```

> Идея передачи по ссылке
> 

Часто, вызывая функцию, мы не хотим копировать наш изначальный объект. Но больше хочется, чтобы изменения, произошедшие в функции, отразились на изначальной переменной. Собственно это и делает передача по ссылке.

> void f(int& a) { … }
> 

В данном случае переменная а увеличилась на единицу в функции, но при этом переменная вне функции также изменилась (по сути это на самом деле и есть эта переменная)

Чуть подробнее про сами ссылки дальше

---

### Перегрузка по ссылке (неоднозначный пример)

```cpp
#include <iostream>

using namespace std;

void f(int a) {
    // code
}

void f(int& a) {
    // code
}

int main() {
    int a = 1;
    int& b = a;
    
    f(a); // CE
    f(b); // CE
    return 0;
}
```

> Что происходит и почему CE?
> 

Стоит понимать ссылки, как “тоже самое под другим названием”. Поэтому такая перегрузка функций работает на уровне создания, но нормально их вызывать не получится.

---

# Указатели, ссылки

Когда мы создаем какую-либо переменную, она, очевидно, где-то в памяти должна находится.

```cpp
#include <iostream>

using namespace std;

int main() {
    int a = 1;
    int* pointer = &a;
    cout << pointer << '\n';
    cout << *pointer << '\n';
    return 0;
}
```

> &a
> 

Чтобы взять у переменной адрес в памяти, используется амперсанд.

> int*
> 

Это как раз тип указателя на инт. type* означает, что в этой переменной лежит адрес чего то типа type.

> cout << pointer;
> 

Указатель можно вывести, но если мы это сделаем, то получим адрес в памяти, который просто как адрес нам мало чем поможет)

> cout << *pointer;
> 

Указатели можно разыменовывать, чтобы узнать содержимое памяти по конкретному адресу.

---

```cpp
#include <iostream>

using namespace std;

int main() {
    int a = 1;
    int& b = a;
    b++;
    cout << a << ' ';
    return 0;
}
```

> int& b = a;
> 

Объявили переменную b, которая является ссылкой на a. Это значит, что мы по сути сделали новое называние для существующей переменной. Везде, где мы используем b означает ровно тоже самое, как если бы мы использовали a.

> b++;
cout << a << ‘ ‘;
> 

В качестве примера. Изменяем b, но а также изменится, что можно понять из вывода.

---

# Массивы

```cpp
#include <iostream>

using namespace std;

int main() {
    int a[100];
    int b[] = {1, 2, 3, 4, 5, 6};
    int c[100] = {1, 2, 3, 4, 5, 6};
    int d[5][5];

    int n;
    cin >> n;
    int e[n]; // =<

    cin >> a[1];
    cout << a[1];

    for (int i = 0; i < n; i++) {
        cin >> e[i];
    }
}
```

> int a[100];
> 

Так мы создали массив длины 100. Далее просто другие способы объявления массива.

> int b[] = {1, 2, 3, 4, 5, 6};
> 

Можно не указывать размер массива, если мы задаем его перечислением.

> int c[100] = {1, 2, 3, 4, 5, 6};
> 

Создали массив длины 100, но при этом задали первые 6 его элементов (остальные нули).

> int d[5][5];
> 

Двумерный массив (по аналогии можно создать и больше мерностей)

> int e[n];
> 

Массив переменной длины. Так делать не рекомендуется (лучше создать массив большой, размера 10’000 например и не использовать не нужное, это связано с расположением в памяти)

> cin >> e[i];
> 

Индексы в массивах от 0 до n - 1 (где n - размер массива). Например, считать весь массив.

---

# Vector!

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> a(100);
    vector<int> b = {1, 2, 3, 4, 5, 6, 7};
    vector<int> c(100, 1);
    vector<vector<int>> d;
    vector<vector<int>> e(100, vector<int> (50));
    vector<int> vec;
    
    int n;
    cin >> n;
    vector<int> v(n);

    cin >> a[1];
    cout << a[1];

    for (int i = 0; i < n; i++) {
        cin >> v[i];
    }
}
```

Способы создания:

> vector<int> a(100);
> 

Аналогия int a[100]; Создали вектор длины 100 (по умолчанию заполнен нулями)

> vector<int> b = {1, 2, 3, 4, 5, 6, 7};
> 

Аналогично можно создать вектор перечислением.

> vector<int> c(100, 1);
> 

Вектор, в котором заданы элементы по умолчанию.

> vector<vector<int>> d;
> 

Двумерный пустой вектор

> vector<vector<int>> e(100, vector<int> (50));
> 

Двумерный вектор размера 100 х 50

> vector<int> v(n);
> 

Вектор длины n (как раз с переменной длиной рекомендую делать так).

---

### Vector - методы

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    cout << a.size() << '\n'; // n
    cout << a.front() << '\n'; // a[0]
    cout << a.back() << '\n';  // a[n - 1]
    cout << a.at(n) << ' ' << a.at(1) << '\n'; // RE, a.at(1) = a[1];
    cout << a.empty() << '\n'; // false;
    
    a.pop_back();
    a.push_back(1);
    a.clear();
    
    a.begin();
    a.end();
}
```

> a.size(); - возвращает актуальное количество элементов
> 

> a.front(); - возвращает первый элемент
> 

> a.back(); - возвращает последний элемент
> 

> a.at(i); - дает элемент по индексу i
*в случае ошибки индекса (обращение за границы) кидает ошибку, а не UB (неопределенное поведение)
> 

> a.empty(); - возвращает true/false (если вектор пустой → true)
> 

В отличие от массива вектор можно менять по размеру

> a.pop_back(); - удаляет последний элемент
> 

> a.push_back(1); - добавляет новый элемент в конец вектор
> 

> a.clear(); - удаляет все элементы вектора (не очищает память!)
> 

> a.begin(); - указатель на началбный элемент
a.end(); - указатель ЗА последний элемент
*в действительности это итераторы, но это вам пока не надо
> 

---

# <algorithm>

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

using namespace std;

int main() {
    int n; cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    int b[100];
    for (int i = 0; i < 100; i++)
        cin >> b[i];

    sort(a.begin(), a.end());
    sort(b, b + 100);

    reverse(a.begin(), a.end());
    reverse(b, b + 100);

    cout << count(a.begin(), a.end(), 1) << '\n';
    cout << *find(a.begin(), a.end(), 1) << '\n';
    return 0;
}
```

Есть достаточно полезная встроенная библиотека <algorithm>.  Мы часто будем с ней сталкиваться, поэтому рассмотрим некоторые функции из нее)

> sort(a.begin(), a.end());
sort(b, b + 100);
> 

Пока что рассуждайте, что итератор=указатель (вообще любой указатель это итератор)
А так это функция, которая сортирует отрезок между некоторым началом и концом.

sort принимает два итератора (на начало и ЗА последний элемент). С a.begin() и a.end() в целом все понятно - это как раз функции, которые нужны для получения этих итераторов.

Но с массивом это выглядит необычно. В действительности b это указатель на первый элемент. Т.к. к указателю можно прибавить число, то в b + 100 как раз окажется указатель за последний элемент.

> reverse(a.begin(), a.end());
reverse(b, b + 100);
> 

С точки зрения использования эта функция работает также, как и sort(), только вместо сортировки просто разворачивает вектор/массив. 

> count(a.begin(), a.end(), 1);
> 

Функция, которая используется для подсчета количества определенных элементов.

> find(a.begin(), a.end(), 1);
> 

Дает нам указатель на первый элемент, равный заданному (в реальности итератор, поэтому без разыменования его не вывести.
*Можно получить индекс, если посчитать find(a.begin(), a.end(), 1) - a.begin();

---

# Фичи (полезные и не только)

```cpp
#include <iostream>

using namespace std;

void f(int a, double b);

void g() {
    f(1, 1.0);
}

void f(int a, double) {
    if (a == 1) return;
    g();
    cout << "Let's go" << '\n';
}

void solve() {
    f(2, 2.0);

    int a[100];
    cout << a[1] << ' ' << 1[a] << '\n';
    int* b = a + 100;
    cout << b[-1] << ' ' << b[-2] << '\n';
}

int main() {
    cin.tie(0);  // cin.tie(nullptr);
    cout.tie(0); // cout.tie(nullptr);
    ios_base::sync_with_stdio(0); // false;
    
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

> void f(int a, double b);
> 

Функции можно объявить до определния самого тела (например, это нужно когда две функции вызывают друг друга)

> void f(int, double) { … }
> 

Если некоторые аргумента не используются в функции, то можно не прописывать им названия, а просто написать тип

> int a[100];
cout << a[1] << ' ' << 1[a] << '\n';
> 

Забавно, но в с++ a[i] это тоже самое, что *(a + i), поэтому 1[a] == *(1 + a) и работает вполне корректно

> int* b = a + 100;
> 

В действительности a это указатель, поэтому к нему можно что нибудь добавить некоторое число)

> cout << b[-1] << ' ' << b[-2] << '\n';
> 

Так как b теперь указывает за последний элемент, то если мы возьмем b[-1], то получим 
b[-1] = *(b - 1) = *(a + n - 1) = a[n - 1] - последний элемент)

> cin.tie(0);                                     // cin.tie(nullptr);
cout.tie(0);                                  // cout.tie(nullptr);
ios_base::sync_with_stdio(0); // false;
> 

На уровне системы это “как-то” ускоряет ввод/вывод. Как это работает “под капотом” на олимпиадах можно в целом и не знать.

С точки зрения кодстайла лучше писать закомментированную версию (так не будет неявных конверсий)

---

# Ending

$© \text { Created by Anton Vitiuk 09.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)