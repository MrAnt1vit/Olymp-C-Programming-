# VII Binary Search

---

# Общее понимание

### Идея

- Представим себе такую задачу: дан массив (вектор длины N), отсортированный по возрастанию. Далее идет Q запросов в виде одного числа. Для каждого из чисел надо вывести индекс этого числа в исходном массиве или сообщить, что элемента там не было.
- Конечно, для этого можно использовать обычный поиск, но тогда на каждый запрос мы будем отвечать за линейное время (O(N)), а значит общая асимптотика будет O(NQ), что достаточно много.
- Бинарный поиск позволяет выполнять поиск за O(log n). В общем понимании, мы проводим несколько итераций, на каждой из них мы уменьшаем вдвое диапазон, в котором может находится искомое число. Для этого мы разделяем возможный диапазон пополам, узнаем, в какой из частей число может находится и фиксируем это.
- Таким образом, если мы выполнили k операций, то искомый диапазон теперь не больше, чем $\frac{n}{2^k}$, значит, когда станет $2^k \geq n$, то алгоритм закончится. То есть $k \leq \log_2n$, значит асимптотика O(log n).

![image.png](VII%20Binary%20Search%2011f2e807d74f803285d4d30d441a5ab8/image.png)

---

### Базовая реализация

- Введем данные, тут я задерживаться не буду. Дальше заведем переменные для границ: left и right. Замечу, что в нашей реализации будем пользоваться полуинтервалами. Это значит, что в любой момент времени возможное положение искомого числа (x) left или правее, но сторого левее right. (Т.е. полунтервал [left, right) ).
- Дальше, пока возможный интервал не станет длиной в один элемент (right - left > 1), будем искать середину полуинтервала и проверять, в какой из половинок лежит x.

![image.png](VII%20Binary%20Search%2011f2e807d74f803285d4d30d441a5ab8/image%201.png)

- Для того, чтобы узнать, в какой из половин лежит элмент (кого двигать: left или right?), надо посмотреть на средний элемент (a[mid], mid = (left + right) / 2). Если $a[mid] \leq x$, то двигать надо левую границу. Аналогично, если $a[mid] > x$, то двигать надо правую.
- Обратите внимание на то, что равенство достигается только при левом индексе, т.к. по индексу left может находится x, а по индексу right уже нет (полинтервалы!!).

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void solve() {
    int n, x;
    cin >> n >> x;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    // if not sorted
    sort(a.begin(), a.end());

    int left = 0, right = n;
    while (right - left > 1) {
        int m = (left + right) / 2;
        if (a[m] <= x) left = m;
        else right = m;
    }
    if (a[left] == x) cout << left + 1 << '\n';
    else cout << -1 << '\n';
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

> Замечение, что чаще я буду использовать left = -1. Это объясняется тем, что в действительности по индексу -1 внутри цикла мы ничего не спросим, но в зависимости от задачи иногда надо, чтобы выполнялось right = 0. Это означает, что все элементы вектора больше x. 
В целом идея того, что можно индексы вынести на 1 за актуальный диапазон, позволяет не задумываться кого надо изначально “ставить за границу”, а кого нет.
> 

---

### Пример (Задачи A и B)

![image.png](VII%20Binary%20Search%2011f2e807d74f803285d4d30d441a5ab8/image%202.png)

- В задаче А не будет кода, т.к. он по сути написан выше (за исключением того, что запросов много). Я скорее хочу подметить то, что мы действительно находим самое правое вхождение т.к. всегда выполняется, что $a[right] > x$. Это гарантирует, что следующий за left элемент по итогу будет другим, а значит мы нашли то, что искали.

![image.png](VII%20Binary%20Search%2011f2e807d74f803285d4d30d441a5ab8/image%203.png)

- В этой задаче воспользуемся тем, что можно “ориентировать полуинтервалы в другую сторону”. То есть теперь будет не [left, right), а (left, right]. А значит и равенство нужно будет в другом месте.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    int q;
    cin >> q;
    for (int i = 0; i < q; i++) {
        int x;
        cin >> x;
        int left = -1, right = n;
        while (right - left > 1) {
            int mid = (left + right) / 2;
            if (a[mid] >= x) {
                right = mid;
            } else {
                left = mid;
            }
        }
        if (right == n || a[right] != x) cout << -1 << ' ';
        else cout << right + 1 << ' ';
    }
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

# “Вариации бин поиска”

### Бинарный поиск по ответу (Задача D как пример)

- На самом деле в задачах на олимпиадах вам почти не нужен будет бин поиск в оригинальном формате с поиском по какому то массиву или подобному. Тем более, что для этого есть встроенные функции (о них, может, позже).
- В действительности вы будете искать некоторый ответ или значение, которого вы не знали, но можете его узнать похожей логикой. Например, задача D. Мы не ищем индекс в массиве, но при этом можем пользоваться бинарным поиском.

![image.png](VII%20Binary%20Search%2011f2e807d74f803285d4d30d441a5ab8/image%204.png)

- Очевидно, что до какого-то момента размеры не будут подходить, т.к. на доске не поместится столько дипломов, сколько требуется. Но при этом с какого то момента на любую доску размера ≥ искомого дипломы помесятся.
- Тогда давайте сделаем бинарный поиск по размеру доски (по ответу). Будем фискировать некоторое значение и узнавать, сколько дипломов мы сможем расположить. В зависимости от того, больше ли это чем n двигаем left или right.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;
typedef long long ll;

ll count(ll w, ll h, ll size) {
    return (size / w) * (size / h);
}

void solve() {
    ll w, h, n;
    cin >> w >> h >> n;

    ll l = 0, r = max(w, h) * ceil(sqrt(n)) + 1;
    while (r - l > 1) {
        ll mid = (l + r) / 2;
        ll cnt = count(w, h, mid);
        if (cnt >= n) {
            r = mid;
        } else {
            l = mid;
        }
    }

    cout << l << '\n';
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

- Вынесем функцию подсчета отдельно, чтобы не усложнять бин поиск.
- Также заметим, что r мы ставим достаточно большим, но в связи с тем, что нельзя оставить его просто порядка $10^{15}$, т.к. тогда в функции подсчета может произойти переполнение. Поэтому найдем некоторое значение, которого точно хватит, но при этом не слишком большое. (В частности в этой задаче можно представить, что все дипломы квадртатные и на основе этого узнать, какое значение точно подойдет).
- В функции count считаем сколько поместится дипломов по каждой из сторон, т.к. оптимально их располагать “вполтную” друг к другу.

---

### Вещественный поиск (задача E)

- В некоторых задачах треубется найти не целое число, а значит условие right - left > 1 уже некорректно. Для этого можно выполнять бин-поиск до тех пор, пока мы не достигнем искомой точности (она, как правило, дана в задачах).
- Также моя личная рекомендация: выносите переменную с некоторым очень маленьким значением в глобальную область. Это может здорово облгечить написание кода в будущем.

![image.png](VII%20Binary%20Search%2011f2e807d74f803285d4d30d441a5ab8/image%205.png)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>

using namespace std;

typedef long long ll;
typedef long double ld;

ld cnt(ld x) {
    return x * x + sqrt(x);
}

void solve() {
    ld C;
    cin >> C;

    ld l = 0, r = C + 1;
    while (r - l > 1e-7) {
        ld m = (r + l) / 2;
        if (cnt(m) > C) r = m;
        else l = m;
    }

    cout << fixed << setprecision(10);
    cout << l;
}

int main() {
    cin.tie(nullptr);
    cout.tie(nullptr);
    ios_base::sync_with_stdio(false);
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

> cout << fixed << setprecision(10);
> 
- Для того, чтобы выводить числа с опеределнной точностью, надо прописать эту строку, тогда все числа будут выводится с 10 знаками после запятой. (Если поставить другое число, то будет выводится другое число знаков соответственно)
- Для этого нужна библиотека iomanip (input-output-manipulations)

---

### Еще одна вариация (Задача F)

- Не всегда асимптотика O(n log n) возникает как “n бин поисков”. В таких задачах, как F, работает “бин-поиск с условием за n”. То есть сам бинпоиск работает за log n, но, чтобы понять какую границу надо двигать необходимо линейное время.

![image.png](VII%20Binary%20Search%2011f2e807d74f803285d4d30d441a5ab8/image%206.png)

- Идея решения все та же: ищем ответ бинарным поиском. Фиксируем длину, которую мы хотим набрать и считаем, сколько таких кусочков мы сможем получить (как раз этот подсчет и будет работать за O(N)).

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;
typedef long long ll;

ll count(vector<int>& vec, int len) { // could be more than int =(
    ll res = 0;
    for (auto i: vec) {
        res += i / len;
    }
    return res;
}

void solve() {
    int n, k;
    ll sum = 0;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        sum += a[i];
    }

    int l = 0, r = 1e8;
    while (r - l > 1) {
        int m = (l + r) / 2;
        if (count(a, m) >= k) l = m;
        else r = m;
    }
    cout << l << '\n';
}

int main() {
    int t = 1;
//    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

# Ending

$© \text { Created by Anton Vitiuk 10.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)