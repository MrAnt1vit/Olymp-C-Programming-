# VIII Sorts.

---

# Квадратичные сортировки

### Сортировка пузырьком

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image.png)

- Выполняем $n - 1$ итарацию. За каждую итерацию мы выставим очередной элемент в конце массива. А значит, расположив в нужном порядке последние $n - 1$ элемент, мы выставим и оставшийся.
- В ходе каждой итерации будем проходить по массиву “слева направо” проверяя соседние элементы и меняя их, если они стоят не в том порядке относительно друг друга.
- Асимптотика $O(n^2)$

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%201.png)

```cpp
void bubble_sort(vector<int>& a) {
    int n = a.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (a[j] > a[j + 1]) {
                swap(a[j], a[j + 1]);
            }
        }
    }
}
```

---

### Сортировка выбором (на максимум)

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%202.png)

- Аналогично выполняем $n - 1$ итерацию, выставляя очередной элемент с конца.
- В этот раз пройдем по оставшейся части массива и запомним, где находится максимальный элемент. Затем поставим его на нужную позицию.
- $O(n^2)$

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%203.png)

```cpp
void choosing_sort(vector<int>& a) {
    int n = a.size();
    for (int i = n - 1; i >= 0; i--) {
        int ind = i;
//        for (int j = 0; j <= i; j++)
        for (int j = ind; j >= 0; j--) {
            if (a[j] > a[ind]) ind = j;
        }
        swap(a[i], a[ind]);

    }
}
```

---

### Сортировка вставками

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%204.png)

- Проходим по массиву. Для каждого элемента находим его позицию в итоговом массиве (изначально пустом). Затем проводим “вставку”: сдвигаем все элементы на 1 вправо после того места, куда мы хотим поставить текущий элемент.
- Асимептотика: $O(n^2)$

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%205.png)

```cpp
void insert_sort(vector<int>& a) {
    int n = a.size();
    vector<int> res;
    for (int i = 0; i < n; i++) {
        int ind = 0;
        while (ind < i && res[ind] <= a[i]) ind++;

//        res.insert(res.begin() + ind, a[i]);
        res.push_back(0);
        for (int j = i; j > ind; j--) {
            res[j] = res[j - 1];
        }
        res[ind] = a[i];
    }
    a = res;
}
```

---

# Быстрые сортировки

### Сортировка подсчетом

* Все числа по модулю не больше 100’000. 

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%206.png)

- Подсчитаем в векторе (cnt) число элементов каждого значения. Затем пройдем по этому массиву и запишем числа по порядку в нужном количестве.
- Зная, что числа находятся в каком-то относительно небольшом диапазоне, можно этим пользоваться (мы не сможем просто создать большой вектор, т.к. числа могут быть большие или же отрицательные). Найдем минимум в массиве и вычтем его из всех элементов. Когда будем записывать результат добавим обратно тот самый минимум.
- Асимптотика $O(n + k), k = \max(a)-  \min(a)$

![Untitled.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/Untitled.png)

```cpp
void count_sort(vector<int>& a) {
    vector<int> count(200'010); // !!!

    for (auto i: a) count[i + 100'000]++;

    int ind = 0;
    for (int i = 0; i < count.size(); i++) {
        for (int j = 0; j < count[i]; j++) {
            a[ind] = i - 100'000;
            ind++;
        }
    }
}
```

---

### Сортировка слиянием

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%207.png)

- Разобьем сортировку на две части. Но для начала проверим, что массив длины > 1. А то есть у него длина 1, то он уже отсортирован.
- В первой части разобьем массив на две части (пополам): левую и правую $(left\ \& \ right)$. Рекурсивно отсортируем эти части. То есть запустим merge_sort от этих частей (тут рекомендую самому разобрать с примером каким-нибудь)
- Во второй части мы уже имеем две отсортированные части, которые теперь надо обьединить. Для этого посмотрим на минимальные элементы. Очевидно, что минимальный элемент на всем отрезке это один из них. Допустим, это элемент с левой части. Тогда поставим этот элемент на первое место и “сдвинем” указатель на единичку вправо. Теперь минимальный из оставшихся элементов это либо нулевой с правой части, либо первый с левой части. Выберем соответсвтующий и сдвинем указатель снова.
- Будем продолжать так до тех пор, пока один из массивов не закончится. Дальше просто в конце припишем оставшуюся часть оставшегося массива. Получили как раз отсортированный массив.
- Асимптотика будет $O(n \log n)$. Она идет из того, что раздробить массив на части можно $\log n$ раз. На первом этапе у нас весь массив, на втором два массива по $\frac{n}2$ элементов, дальше 4 массива по $\frac n 4$ элементов и тд $( \log n)$. Получаем суммарно как раз $O(n \log n)$

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%208.png)

```cpp
void merge_sort(vector<int>& a) {
    if (a.size() == 1) return;

    int n = a.size();
    vector<int> left(n / 2);
    vector<int> right(n - n / 2); // == right((n + 1) / 2)
    for (int i = 0; i < n / 2; i++) {
        left[i] = a[i];
    }
    for (int i = n / 2; i < n; i++) {
        right[i - n / 2] = a[i];
    }
    merge_sort(left);
    merge_sort(right);

    // merge
    int i = 0, j = 0;

    while (i < n / 2 && j < n - n / 2) {
        if (left[i] <= right[j]) {
            a[i + j] = left[i];
            i++;
        } else {
            a[i + j] = right[j];
            j++;
        }
    }
    while (i < n / 2) {
        a[i + j] = left[i];
        i++;
    }
    while (j < n - n / 2) {
        a[i + j] = right[j];
        j++;
    }
}

```

---

### Быстрая соровка

* Код к быстрой сортировке знать не обязтельно, но лучше знать, чем не знать)

- Суть в том, что на каждом этапе мы выбираем случайный элемент и разбиваем массив на две части так, что в левой числа ≤ этого элемента, а в правой части ≥ этого элемента. Дальше, аналогично merge_sort сортируем левый и правый блок.
- Тогда в среднем qsort работает за $O(n\log n)$

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%209.png)

```cpp
int partition(vector<int>& a, int l, int r) {
    int pivot = a[r];
    int i = l - 1;
    for (int j = l; j <= r - 1; j++) {
        if (a[j] <= pivot) {
            i++;
            swap(a[i], a[j]);
        }
    }
    swap(a[i + 1], a[r]);
    return i + 1;
}

void qsort(vector<int>& a, int l = 0, int r = sz - 1) {
    if (l < r) {
        int p = partition(a, l, r);
        qsort(a, l, p - 1);
        qsort(a, p + 1, r);
    }
}
```

---

# Больше сортировок (+ компаратор)

### Компаратор и применения (задача 6)

- Часто в задачах нужно отсортировать как-либо по особенному. Чтобы не писать для этого собственную сортирвку, существует компаратор. Компаратор — это такая функция, которая возвращает $bool$, принимает два элемента вектора. Она должна вернуть true, если первый элемент в итоговом массиве должен лежать строго левее, чем второй.
- Чтобы его использовать, его надо просто передать третим аргументом в сортировку.

```cpp
bool cmp(int a, int b) { // true a < b // a lefter b
    return abs(a) < abs(b);
}

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    sort(a.begin(), a.end(), cmp);

    for (int i = 0; i < n; i++) {
        cout << a[i]  << ' ';
    }
}
```

- Пример задачи. Здесь мы хотим отсортировать строки в таком порядке, чтобы они образовывали минмиально-возмужную при конкетенации. Чтобы сильно не заморачиваться просто будем ставить их так, чтобы $(\text{a левее b, если } a + b < b + a)$.

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%2010.png)

```cpp
bool cmp(string& a, string& b) { // true a < b // a lefter b
    return a + b < b + a;
}

void solve() {
    int n;
    cin >> n;
    vector<string> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    sort(a.begin(), a.end(), cmp);
    for (int i = 0; i < n; i++) {
        cout << a[i];
    }
}
```

---

### Bogosort

- Кода не будет, это просто забавная сортировка =)
- В общем смысл такой: перемешиваем массив и проверяем, что он отсортирован. Эта штука не имеет верхней границы по времени, но, даже в среднем, очевидно, выполняется очень и очень долго)))

---

### Stalin sort

- Кода не будет, это просто забавная сортировка =)
- А эта сортироввка заключается в том, чтобы просто пройти по массиву и вырезать все элементы, которые “мешают ему быть отсортированным”.

![image.png](VIII%20Sorts%201212e807d74f8012a9d2ff4d2f49fc43/image%2011.png)

---

# Ending

$© \text { Created by Anton Vitiuk 10.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)