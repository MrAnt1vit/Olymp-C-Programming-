# IV Stack. Deque. Queue.

---

# Stack

### Идея + описание

> Основная идея стека в том, что мы можем класть в элементы в конец и доставать их с конца. Например, если я положил элементы в порядке 1 2 3 4 5, то достать я их смогу только в порядке 5 4 3 2 1.
> 

> По сути, можно воспринимать стек как “пробирку”, из которой мы не можем доставать нижние элементы, пока не достанем верхние.
> 

> Чтобы пользоваться стеком, надо подключить библиотеку <stack>.
> 

![image.png](IV%20Stack%20Deque%20Queue%201132e807d74f80678848e498809fcaef/image.png)

---

### Методы

```cpp
#include <iostream>
#include <stack>

using namespace std;

void solve() {
    stack<int> st;
    int n = 5;
    for (int i = 0; i < n; i++)
        st.push(i);
    cout << st.size() << '\n';  // 5
    cout << st.empty() << '\n'; // false
    
    while (!st.empty()) {
        cout << st.top() << ' '; // 4 3 2 1 0
        st.pop();
    }
    cout << st.size() << '\n';  // 0
    cout << st.empty() << '\n'; // true
}
```

> #include <stack>
> 

Подключаем библиотеку <stack> для возможности использования stack’a.

> stack<int> st;
> 

Аналогично вектору, чтобы обьявить стек, надо указать тип данных, который будет лежать в структуре.

> st.push(i);
> 

Кладем элемент в конец стека

> st.size();
> 

Можем узнать размер стека

> st.empty();
> 

Получаем true или false в зависимости от пустоты стека. (пустой → true)

> st.top();
> 

Узнаем верхний элемент стека. Если такого нет, то получим, вероятно RE.

> st.pop();
> 

Удаляем верхний элемент стека.

---

### Реализация на массиве (Задача 1)

![image.png](IV%20Stack%20Deque%20Queue%201132e807d74f80678848e498809fcaef/image%201.png)

```cpp
#include <iostream>
#include <stack>

using namespace std;

void solve() {
    int a[100], n, sz=0;
    string command;
    cin >> command;

    while (command != "exit") {
        if (command == "push") {
            cin >> n;
            a[sz] = n;
            sz++;
            cout << "ok\n";
        } else if (command == "pop") {
            cout << a[sz - 1] << '\n';
            // a[sz - 1] = 0;
            sz--;
        } else if (command == "back") {
            cout << a[sz - 1] << '\n';
        } else if (command == "size") {
            cout << sz << '\n';
        } else if (command == "clear") {
            sz = 0;
            cout << "ok\n";
        }
        cin >> command;
    }
    cout << "bye";
}

int main() {
    solve();
    return 0;
}
```

> int a[100], n, sz=0;
> 

Создаем массив, в котором будем хранить стек (по условию мы знаем что его размер не больше 100). Переменная n, которую мы будем считывать для добавления в стек, а также переменная для размера стека.

> string command;
cin >> command;
> 

Считываем очередную команду (в частности цикл можно заменить на do { … } while, если хочется).

> if (command == "push") {
    cin >> n;
    a[sz] = n;
    sz++;
    cout << "ok\n";
}
> 

Считываем новое число. Т.к. размер стека был sz, то индекс последнего элемента был sz-1, а значит новый элемент будет лежать по индексу sz. Записываем в соотвествующий индекс число и увеличиваем размер на 1.

> else if (command == "pop") {
    cout << a[sz - 1] << '\n';
    // a[sz - 1] = 0;
    sz--;
}
> 

Последний элемент лежит по индексу sz-1. Уменьшаем размер на 1. Если хочется, можно обнулить удаленный элемент, обозначив как бы, что мы его удалили

> else if (command == "back") {
    cout << a[sz - 1] << '\n';
}
> 

Аналогично, просто мы не уменьшаем размер стека.

> else if (command == "size") {
    cout << sz << '\n';
}
> 

Размер стека, что тут добавить)

> else if (command == "clear") {
    sz = 0;
    cout << "ok\n";
}
> 

Так как нам в действительности не надо удалять элементы, мы можем просто обнулить значение размера (в реальности так работает .clear в векторе, кстати).

> cin >> command;
> 

Вводим следующую команду)

- Если интересно, есть задача аналогичная с зашитой от ошибок (например, вы должны вывести error, если стек пустой на запросе удаления)

---

### Правильные скобочные последовательности (ПСП) (Задача 3)

Есть разные определения ПСП. Для полноты картины я перечислю некоторые из них.

- Последовательность скобок, которую можно долнинить числами и арифмитическими знаками так, чтобы получилость корректное арифмитическое выражение.
- Последовательность скобок такая, что каждой открывающей скобки соответствует некоторая закрывающая, причем, если обозначить отрезки с концами в этих скобках. То можно сказать, что любые два отрезка либо не пересекаются, либо один входит в другой.
Иначе говоря, скобки разбиты на пары “корректно”.
- Рекурсивное определение
    - (), [], {} - ПСП (пустая строка тоже ПСП).
    - Если A - ПСП, то (A), [A], {A} также ПСП.
    - Если A, B - ПСП, то AB также ПСП.

![image.png](IV%20Stack%20Deque%20Queue%201132e807d74f80678848e498809fcaef/image%202.png)

```cpp
#include <iostream>
#include <stack>

using namespace std;

void solve() {
    stack<char> st;
    st.push('0');
    string str;
    cin >> str;
    for (auto i : str) {
        // str[i] -> i
        // for (int i = 0; i < str.size(); i++)
        if (i == '(' || i == '[' || i == '{')
            st.push(i);
        else if (i == ')' && st.top() == '(')
            st.pop();
        else if (i == '}' && st.top() == '{')
            st.pop();
        else if (i == ']' && st.top() == '[')
            st.pop();
        else {
            cout << "no";
            return;
        }
    }
    if (st.size() == 1) cout << "yes";
    else cout << "no";
}

int main() {
    solve();
    return 0;
}
```

Основная идея решения в том, что будем хранить на стеке открытые скобки, которым еще “не нашли пару”. Как только мы ее находим, то удаляем соответсвующую открывющую скобку

> stack<char> st;
st.push('0');
> 

Положим “фейковый” символ в стек, чтобы мы были уверены в том, что стек всегда не пуст (и не ловить ошибки на .empty()).

> if (i == '(' || i == '[' || i == '{')
    st.push(i);
> 

Если скобка открывающая, то просто положим ее на стек.

> else if (i == ')' && st.top() == '(')
    st.pop();
else if (i == '}' && st.top() == '{')
    st.pop();
else if (i == ']' && st.top() == '[')
    st.pop();
> 

Если скобка закрывающая, то мы должны дать ей в пару соответствующую открыввающую.

> else {
    cout << "no";
    return;
}
> 

Если закрывающей скобке не сопоставилась открывающая, то значит последовательность не ПСП.

> if (st.size() == 1) cout << "yes";
else cout << "no";
> 

В конце проверки надо, чтобы не осталось никаких открывающих скобок на стеке (но мы помним, что там лежит фиктивный ноль).

---

# Queue

### Идея + описание

> Основная идея очереди в том, что мы можем класть в элементы в конец и доставать их с начала. Например, если я положил элементы в порядке 1 2 3 4 5, то достать я их смогу только в порядке 1 2 3 4 5.
> 

> По сути, можно воспринимать стек как “тонель”, из которого элементы выходят в том же порядке, что и зашли.
> 

> Чтобы пользоваться очедерью, надо подключить библиотеку <queue>.
> 

![image.png](IV%20Stack%20Deque%20Queue%201132e807d74f80678848e498809fcaef/image%203.png)

---

### Методы

```cpp
#include <iostream>
#include <queue>

using namespace std;

void solve() {
    queue<int> st;
    int n = 5;
    for (int i = 0; i < n; i++)
        st.push(i);
    cout << st.size() << '\n';  // 5
    cout << st.empty() << '\n'; // false

    while (!st.empty()) {
        cout << st.front() << ' '; // 0 1 2 3 4
        st.pop();
    }
    cout << st.size() << '\n';  // 0
    cout << st.empty() << '\n'; // true
}
```

> #include <queue>
> 

Подключаем библиотеку <queue> для возможности использования очереди.

> queue<int> st;
> 

Аналогично вектору, чтобы обьявить очередь, надо указать тип данных, который будет лежать в структуре.

> st.push(i);
> 

Кладем элемент в конец очереди

> st.size();
> 

Можем узнать размер очереди

> st.empty();
> 

Получаем true или false в зависимости от пустоты очереди. (пустой → true)

> st.front();
> 

Узнаем первый элемент очереди. Если такого нет, то получим, вероятно RE.

> st.pop();
> 

Удаляем первый элемент очереди.

---

### Реализация на массиве (Задача 2)

![image.png](IV%20Stack%20Deque%20Queue%201132e807d74f80678848e498809fcaef/image%204.png)

```cpp
#include <iostream>

using namespace std;

void solve() {
    int a[101], n;
    int begin = 0, end = 0;
    // [begin, end)

    string command;
    cin >> command;

    while (command != "exit") {
        if (command == "push") {
            cin >> n;
            // ...
            // end - 2, end - 1, end
            // begin, begin + 1
            a[end] = n;
            end++;
            if (end == 101)
                end = 0;
            cout << "ok\n";
        } else if (command == "pop") {
            cout << a[begin] << '\n';
            begin++;
            if (begin == 101)
                begin = 0;
        } else if (command == "front") {
            cout << a[begin] << '\n';
        } else if (command == "size") {
            if (begin > end)
                cout << 101 - begin + end << '\n';
            else
                cout << end - begin << '\n';
        } else if (command == "clear") {
            begin = end = 0;
            cout << "ok\n";
        }
        cin >> command;
    }
    cout << "bye";
}
```

> В целом аналогично стеку на массиве, только вместо размера мы будем хранить начало и конец очереди (причем в виде [begin, end), чтобы удобнее считать размеры.
> 

> Также для того, чтобы end не мог совпасть с begin мы сделаем массива размера 101.
> 

> Также надо грамотно рассмотреть случай, когда конец очереди “выходит” за пределы массива. В таком случае мы продолжаем ее в начале и как бы “ходим по кругу”.
> 

---

### Реализация на двух стеках (Задача 2)

- Та же задача, но с некоторой другой идеей.
- Можем заметить, что нам не запрещено пользоваться стеками. А значит можно попробовать решить задачу с их помощью.
- Для этого создадим два стека, где один будет отвечать за “начало” очереди и из него мы будем забирать элементы, а другой будет “концом” очереди и элементы класть мы будем именно туда.
- * Рекомендую самостоятельно рассмотреть различные данные и подробнее разобрать, что тут происходит
- Не смотря на то, что операция pop/front может выполнится за O(n), весь код все равно будет работает за O(n) (иначе говоря, O(1) на операцию в среднем)
    - Это можно доказать. Заметим, что каждый элемент в итоге попадает в первый стек, потом переходит во второй, а потом выходит из второго. То есть проходит 3 операции, а это константа.

![image.png](IV%20Stack%20Deque%20Queue%201132e807d74f80678848e498809fcaef/image%204.png)

```cpp
#include <iostream>
#include <queue>
#include <deque>
#include <vector>
#include <stack>

using namespace std;

void solve() {
    int n;
    string command;
    cin >> command;

    stack<int> begin;
    stack<int> end;

    while (command != "exit") {
        if (command == "push") {
            cin >> n;
            end.push(n);
            cout << "ok\n";
        } else if (command == "pop") {
            if (begin.empty()) {
                while (!end.empty()) {
                    begin.push(end.top());
                    end.pop();
                }
            }
            cout << begin.top() << '\n';
            begin.pop();
        } else if (command == "front") {
            if (begin.empty()) {
                while (!end.empty()) {
                    begin.push(end.top());
                    end.pop();
                }
            }
            cout << begin.top() << '\n';
        } else if (command == "size") {
            cout << begin.size() + end.size() << '\n';
        } else if (command == "clear") {
            while (!end.empty()) end.pop();
            while (!begin.empty()) begin.pop();
            cout << "ok\n";
        }
        cin >> command;
    }
    cout << "bye";
}

int main() {
    solve();
    return 0;
}
```

> push n
> 

Добавляем просто во второй стек новый элемент

> pop
> 

Удаляем элемент из первого стека. Если он был пуст, то перед этим перекладываем все элементы второго стека в первый.

> front
> 

Аналогично pop, но не удаляем, а просто перекладываем при необходмости.

> size
> 

Размер очереди - это сумма размеров стеков.

> clear
> 

Очищаем оба стека и помним, что у них нет встроенного метода clear().

---

# Deque

### Идея + описание

> Основная идея дека  в том, что мы можем класть в элементы и в конец, и в начало, а также доставать их и с начала, и с конца (вообще, в деке есть индексация, так что ей тоже можно пользоваться).
> 

> По сути, можно воспринимать стек как “двустороннюю очередь”.
> 

> Чтобы пользоваться очедерью, надо подключить библиотеку <deque>.
> 

---

### Методы

```cpp
#include <iostream>
#include <deque>
using namespace std;

void solve() {
    deque<int> deq;
    int n = 5;
    for (int i = 0; i < n; i++)
        deq.push_back(i);
    for (int i = 0; i < n; i++)
        deq.push_front(i);
    cout << deq[0] << '\n'; // 4
    cout << deq.size() << '\n';  // 10
    cout << deq.empty() << '\n'; // false

    while (!deq.empty()) {
        cout << deq.front() << ' '; // 4 4 3 3 2 2 1 1 0 0 0
        cout << deq.back() << ' ';
        deq.pop_back();
        deq.pop_front();
    }
    cout << '\n';
    cout << deq.size() << '\n';  // 0
    cout << deq.empty() << '\n'; // true
}

int main() {
    solve();
    return 0;
}
```

> #include <deque>
> 

Подключаем библиотеку <deque> для возможности использования дека.

> deque<int> st;
> 

Аналогично вектору, чтобы обьявить дека, надо указать тип данных, который будет лежать в структуре.

> st.push_back(i);
> 

Кладем элемент в конец дека.

> st.push_front(i);
> 

Кладем элемент в начало дека.

> st.size();
> 

Можем узнать размер дека.

> st.empty();
> 

Получаем true или false в зависимости от пустоты дека. (пустой → true)

> st.front();
> 

Узнаем первый элемент дека. Если такого нет, то получим, вероятно RE.

> st.back();
> 

Узнаем последний элемент дека. Если такого нет, то получим, вероятно RE.

> st.pop_front();
> 

Удаляем первый элемент дека.

> st.pop_back();
> 

Удаляем последний элемент дека.

> cout << d[0] << ‘\n’;
> 

В деке есть индексация, как мы и говорили ранее.

---

# Ending

$© \text { Created by Anton Vitiuk 10.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)