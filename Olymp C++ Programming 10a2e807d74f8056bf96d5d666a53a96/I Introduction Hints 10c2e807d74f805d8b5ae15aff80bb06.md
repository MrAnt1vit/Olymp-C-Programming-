# I Introduction. Hints.

---

### A. Слоник

![image.png](I%20Introduction%20Hints%2010c2e807d74f805d8b5ae15aff80bb06/image.png)

- Заметим, что “выгоднее всего” всегда двигаться максимально вперед, пока это можно делать (то есть по 5 клеток вперед). В таком случае кол-во ходов будет равно $\lceil {\frac x 5 } \rceil$.
- Чтобы целочисленно поделить одно число на другое с округлением вверх, можно доказать, что $\frac{a + b - 1} {b} = \lceil \frac a b \rceil$ (левая часть поделена целочисленно). Доказательство остается в качестве упражнения
- Таким образом $\lceil \frac x 5\rceil = \frac{x + 4} 5$. Соответственно решение выглядит след образом:

```cpp
#include <iostream>

using namespace std;

int main() {
    int n;
    cin >> n;
    cout << (n + 4) / 5;
    return 0;
}
```

---

### B. Федя и математика

![image.png](I%20Introduction%20Hints%2010c2e807d74f805d8b5ae15aff80bb06/image%201.png)

- Так как число во входных данных очень большое, то его не получится даже считать в любой целочисленный тип =( А значит считывать его в любом случае придется как строку.
- Если посмотреть на первые 10-20 вариантов (1 ≤ n ≤ 20), то можно найти некоторую закономерность. Для этого, например, можно написать код, который буквально считает это выражение, но на больших числах не работает.
- В этой закономерности замечаем, что при делимости на 4 ответ 4, и 0 в остальных случаях.

> *Доказать эту закономерность можно, мы делали это на занятии. Если в кратце, то каждое слагаемое можно рассматривать по отдельности и показать, что там везде образуется цикличность по 4.
> 
- Надо проверить делимость числа на 4. Из школьного курса, что для делимости на 4 достаточно делимости на 4 числа, образованного последними 2мя цифрами. Собственно для этого из строчки можно вытащить последние 2 цифры.

> Вспомним, что символы можно вычитать друг из друга, т.к. в действительности это числа. На основе этого можно узнать последние 2 цифры.
> 

> Также, если приписать 0 в начале числа, не надо проверять случай, когда оно однозначеное.
> 

```cpp
#include <iostream>

using namespace std;

int main() {
    string n;
    cin >> n;
    n = "0" + n;

    int last2 = (n[n.size() - 2] - '0') * 10 + (n[n.size() - 1] - '0');
    if (last2 % 4 == 0) cout << 4;
    else cout << 0;
    return 0;
}
```

---

### C. Хороший контест

![image.png](I%20Introduction%20Hints%2010c2e807d74f805d8b5ae15aff80bb06/image%202.png)

> Не ко всем задачам буедт код/весь код, очевидно)
> 
- В действительности нам не нужно знать имена, поэтому их можно просто считать и больше ничего с ними не делать.
- А так, просто в цикле по сути надо проверить условия, данные в задачи и просуммировать кол-во подходящих.

```cpp
#include <iostream>

using namespace std;

int main() {
    string str;
    int x, y, res = 0, n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> str >> x >> y;
        // str is no-needed
        
        // code //
    }
    cout << res;
    return 0;
}
```

---

### ZA. Арбуз

![image.png](I%20Introduction%20Hints%2010c2e807d74f805d8b5ae15aff80bb06/image%203.png)

> Было на занятии =)
> 
- Докажите, что нечетные числа не подходят
- Выясните, какие четные числа подходят, а какие нет

---

### ZB. Укладка доминошками

![image.png](I%20Introduction%20Hints%2010c2e807d74f805d8b5ae15aff80bb06/image%204.png)

> Было на занятии =)
> 
- Попробуйте расставить доминошки, когда одно из чисел четное.
- Очевидно, что когда оба числа нечетны, то останется одна пустая клетка как минимум. Покажите, что всегда можно расставить так, чтобы осталась ровно одна.

---

### ZC. Средство от бессонницы

![image.png](I%20Introduction%20Hints%2010c2e807d74f805d8b5ae15aff80bb06/image%205.png)

- Обратите внимание, что число драконов не такое уж и большое.
- Значит, можно перебирать номера драконов и “в тупую” считать какие из них получили ущерб)

---

### ZD. Куплю лопату

![image.png](I%20Introduction%20Hints%2010c2e807d74f805d8b5ae15aff80bb06/image%206.png)

- Что, если перебирать просто кол-во лопат от 1 до тех пор, пока  не получится?
- Попробуйте показать, что некоторого числа лопат всегда хватит, а значит перебор как минимум будет не бесконечным.

---

# Ending

$© \text { Created by Anton Vitiuk 09.2024}$

[telegram](https://t.me/MrAnt1vit) [vk](https://vk.com/mrant1vit)